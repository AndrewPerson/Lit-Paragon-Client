import { Page } from "../page/page";

import { html } from "lit";
import { customElement, state } from "lit/decorators.js";
import { map } from "lit/directives/map.js";

import { DailyTimetable, BaseBell, Bell, Period } from "schemas/daily-timetable";
import { Timetable } from "schemas/timetable";

import { Resources } from "../../site/resources";

import "./countdown";
import "./bell";
import "./period";

import "../info/info";

import LOGIN_URL from "../../login-url";

import bells from "./bells";

//@ts-ignore
import textCss from "default/text.css";
//@ts-ignore
import imgCss from "default/img.css";
//@ts-ignore
import scrollbarCss from "default/scrollbar.css";
//@ts-ignore
import cardElementCss from "default/pages/card.css";
//@ts-ignore
import pageCss from "default/pages/page.css";
//@ts-ignore
import dailyTimetableCss from "./daily-timetable.css";
import { Time } from "schemas/utils";

@customElement("daily-timetable")
export class StudentDailyTimetable extends Page {
    static styles = [textCss, imgCss, scrollbarCss, pageCss, cardElementCss, dailyTimetableCss];

    @state()
    private _dailyTimetable: DailyTimetable;

    constructor() {
        super();

        this.addResource("dailytimetable", (dailyTimetable: DailyTimetable) => {
            this._dailyTimetable = dailyTimetable;
        });

        this.addEventListener("countdown-finished", (_ => {
            const currentBellIndex = getCurrentBellIndex(this._dailyTimetable, new Date());

            if (currentBellIndex === undefined) {
                getNewDailyTimetable(this._dailyTimetable).then(newDailyTimetable => {
                    if (newDailyTimetable != null) {
                        Resources.set("dailytimetable", JSON.stringify(newDailyTimetable));
                    }
                });
            }
            else {
                this.requestUpdate();
            }
        }) as EventListener);
    }

    renderPage() {
        const currentBellIndex = getCurrentBellIndex(this._dailyTimetable, new Date());
        const nextBell = currentBellIndex === undefined ? undefined : this._dailyTimetable.timetable[currentBellIndex + 1];
        const nextVisibleBell = currentBellIndex === undefined ? undefined : this._dailyTimetable.timetable.splice(currentBellIndex + 1).find(bell => bell.shouldDisplay);

        return html`
            <info-popup style="${this._dailyTimetable.autoGenerated ? "" : "display: none"}">
                <img slot="icon" src="/images/warning.svg">
                This timetable was automatically generated and may be inaccurate. <a href="${LOGIN_URL}">Login</a> for the latest information.
            </info-popup>

            ${
                nextBell === undefined ?
                html`<dt-countdown name="Nothing" .time="${new Date()}"></dt-countdown>` :
                html`<dt-countdown name="${nextBell.name}" .time="${timeToDate(nextBell.startTime, new Date(this._dailyTimetable.date))}"></dt-countdown>`
            }

            <div class="periods">
                ${map(
                    this._dailyTimetable.timetable.filter(bell => bell != null && bell.shouldDisplay) as (Bell | Period)[],
                    (bell: Bell | Period) =>
                        bell.type === "bell" ?
                        html`
                            <dt-bell
                                title=${bell.name}
                                .time=${bell.startTime}
                                ?next=${nextVisibleBell === bell}>
                            </dt-bell>
                        ` :
                        html`
                            <dt-period
                                title=${bell.name}
                                .time=${bell.startTime}
                                teacher=${bell.teacher ?? "No one"}
                                ?teacherChanged=${bell.teacherChanged}
                                room=${bell.room}
                                ?roomChanged=${bell.roomChanged}
                                ?next=${nextVisibleBell === bell}>
                            </dt-period>
                        `
                )}
            </div>
        `;
    }
}

function timeToDate(time: Time, today: Date) {
    //Copy the date to make sure we don't change it
    let date = new Date(today);

    date.setHours(time.hours);
    date.setMinutes(time.minutes);
    date.setSeconds(time.seconds);

    return date;
}

function getCurrentBellIndex(dailyTimetable: DailyTimetable, now: Date) {
    const dailyTimetableDate = new Date(dailyTimetable.date);

    const bells = dailyTimetable.timetable;

    // Bells are sorted in ascending order, so we can just loop through them until we find one that hasn't happened yet
    for (let i = 0; i < bells.length; i++) {
        const endTime = timeToDate(bells[i].endTime, dailyTimetableDate);
        if (endTime.getTime() >= now.getTime()) return i;
    }

    return undefined;
}

async function getNewDailyTimetable(currentDailyTimetable: DailyTimetable) : Promise<DailyTimetable | null> {
    const nextDailyTimetable = await Resources.get<DailyTimetable>("dailytimetable");
    if (nextDailyTimetable !== undefined && getCurrentBellIndex(nextDailyTimetable, new Date()) !== undefined) return nextDailyTimetable;

    const timetable = await Resources.get<Timetable>("timetable");
    if (timetable === undefined) return null;

    const now = new Date();

    let generatedDailyTimetableDate = new Date(currentDailyTimetable.date);
    let lastBell: BaseBell = currentDailyTimetable.timetable[currentDailyTimetable.timetable.length - 1]; // TODO Get this to work if there are no bells.
    let schoolDayDiff = 0;

    // Prevents infinite loops
    let iter = 0;
    while (now > timeToDate(lastBell.endTime, generatedDailyTimetableDate)) {
        generatedDailyTimetableDate.setDate(generatedDailyTimetableDate.getDate() + 1);

        if (generatedDailyTimetableDate.getDay() == 6)
            generatedDailyTimetableDate.setDate(generatedDailyTimetableDate.getDate() + 1);

        if (generatedDailyTimetableDate.getDay() == 0)
            generatedDailyTimetableDate.setDate(generatedDailyTimetableDate.getDate() + 1);

        schoolDayDiff++;

        // 0-14
        const dayNumber = (currentDailyTimetable.dayNumber + schoolDayDiff) % 15;

        const generatedBells = bells[dayNumber];
        lastBell = generatedBells[generatedBells.length - 1];

        if (iter++ > 100) {
            console.error("Infinite loop detected in daily timetable generation.");
            return null;
        }
    }

    const dayNumber = (currentDailyTimetable.dayNumber + schoolDayDiff) % 15;
    const generatedBells = bells[dayNumber];
    const day = timetable.weeks.flatMap(week => week.days)[dayNumber];

    let generatedTimetable = generatedBells.map(bell => {
        if (bell.type == "period") {
            return {
                ...bell,
                ...day.periods[bell.linkedIndex],
                periodIndex: bell.linkedIndex,
                roomChanged: false,
                teacherChanged: false
            } as Period;
        }
        else return bell;
    });

    for (const bell of generatedTimetable.reverse()) {
        if (bell.type == "period") break;

        bell.shouldDisplay = false;
    }

    for (const bell of generatedTimetable.reverse()) {
        if (bell.type == "period") break;

        bell.shouldDisplay = false;
    }

    return {
        date: dateToDailyTimetableDate(generatedDailyTimetableDate),
        dayName: day.dayName,
        dayNumber: dayNumber + 1, // 1-15
        autoGenerated: true,
        timetable: generatedTimetable
    };
}

function dateToDailyTimetableDate(date: Date) {
    // YYYY-MM-DD
    return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")}`;
}
